'use strict';
const Peer = require('./Peer');
const fs = require('fs');
class Message {
	constructor(connection, data) {
		this.service = data.service;
		this.event = data.event;
		this.reply_id = data.reply_id || null;
		this.id = data.id;
		this.from = new Peer(connection, data.from);
		this.to = new Peer(connection, data.to);
		this.flags = data.flags;
		this.out = data.out;
		this.unread = data.unread;
		this.date = data.date;
		this.text = data.text || null;
    this.views = data.views || 0;
		this.tracks = []
		this._registerEvents(connection);
	}

	_registerEvents(connection) {
		this.forward = peer => {
			connection.forward(peer, this.id);
		}

		this.send = msg => {
			this.to.send(msg);
		}

		this.reply = msg => {
			connection.reply(this.id, msg);
		}

		this.sendImage = path => {
			this.to.sendImage(path);
		}

		this.sendDocument = path => {
			this.to.sendDocument(path);
		}

		this.deleteMsg = () => {
			connection.deleteMsg(this.id);
		}

		this.sendTyping = () => {
			this.from.sendTyping();
		}

		this.update = () => {
		  let obj = this;
		  console.log(`update function of ${this.id} called`);
		  if (/*global.LOCK == false*/ true) {
        // global.LOCK = true;
        if (this.tracks.length < 60) {
          connection.getMessage(this.id).then(message => {
            // global.LOCK = false;
            obj.tracks.push({
              date: message.date,
              views: message.views
            });
            // setTimeout(obj.update, 30000);
          });
        } else {
          fs.writeFileSync(__dirname + '/data/db.txt', obj, 'utf-8');
        }
      } else {
        setTimeout(obj.update, 2000);
      }
		}
	}

}

module.exports = Message;
